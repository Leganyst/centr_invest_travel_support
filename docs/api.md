# Backend API Reference

Документация описывает REST-интерфейс бэкенда культурного маршрутизатора. Все эндпоинты базируются на `http://<host>:8080/`. Аутентификации нет, поэтому убедитесь, что API недоступно публично без прокси.

## Общие сведения

- Формат данных: JSON (`Content-Type: application/json`).
- Кодировка: UTF-8.
- Время в ответах — локальное (Ростов-на-Дону).
- Источник мест: 2ГИС. При отсутствии ключа или данных используется сидовый набор из `backend/data/places_seed.json`.
- Кэш: ответы 2ГИС кэшируются в памяти и на диске (`CACHE_DIR`) на `CACHE_TTL_PLACES_SEC` секунд.

## Справочник типов

### Объект `Place`
| Поле | Тип | Описание |
|------|-----|----------|
| `id` | string | Идентификатор точки (из 2ГИС или сидов). |
| `name` | string | Название места. |
| `lat`, `lon` | number | Координаты в десятичных градусах. |
| `city` | string | Город/адрес для отображения. |
| `tags` | string[] | Канонические теги (`history`, `museum`, `art`, `food`, ...). |
| `description` | string | Краткое описание, если доступно. |

### Объект `Stop`
| Поле | Тип | Описание |
|------|-----|----------|
| `name` | string | Название места. |
| `lat`, `lon` | number | Координаты. |
| `arrive`, `leave` | string (ISO8601) | Время прибытия/отправления (локальное время Europe/Moscow). |
| `tags` | string[] | Список тегов, прикреплённых к остановке. |

### Объект `PlanRequest`
```json
{
  "city": "Ростов-на-Дону",
  "date": "2025-10-27",
  "tags": ["history", "food"],
  "budget": "low",
  "pace": "normal",
  "user_location": {
    "lat": 47.2231,
    "lon": 39.7180,
    "accuracy_m": 30
  },
  "radius_m": 1500
}
```
- `city` — опционально, по умолчанию Ростов-на-Дону. Используется как fallback, если нет геопозиции.
- `tags` — произвольный список; приводятся к каноническим тегам через `tags_vocab.json`.
- `budget`, `pace` — пока не влияют на расчёт, но передаются дальше (в т.ч. LLM).
- `user_location` — геопозиция пользователя. Если указано, маршрут стартует отсюда, а поиск мест ограничивается данной точкой.
- `radius_m` — радиус поиска для 2ГИС (100–2000 м, дефолт 2000).

## Эндпоинты

### `GET /healthz`
Простой health-check.

**Response 200**
```json
{"ok": true}
```

### `GET /places`
Возвращает список мест для отладки и ручного тестирования.

**Query-параметры**
| Имя | Тип | По умолчанию | Описание |
|-----|-----|--------------|----------|
| `q` | string | `DGIS_DEFAULT_Q` | Запрос для 2ГИС (например, `музеи`). |
| `lat`, `lon` | number | Центр города | Координаты пользователя. |
| `radius` | int | 2000 | Радиус в метрах (100–2000). |
| `limit` | int | 20 | Количество элементов в ответе. |

**Пример**
```bash
curl "http://localhost:8080/places?q=музей&lat=47.22&lon=39.72&radius=1500&limit=5"
```

**Response 200**
```json
[
  {
    "id": "70000001054701056",
    "name": "Музей современного искусства",
    "lat": 47.22348,
    "lon": 39.71786,
    "city": "Ростов-на-Дону",
    "tags": ["art", "museum"],
    "description": "Актуальные выставки и культурные программы"
  },
  ...
]
```

Если 2ГИС вернул 404 (`itemNotFound`), сервис отдаёт сиды. Конкретных ошибок не возвращается.

### `POST /plan`
Строит однодневный маршрут; использует геопозицию пользователя при поиске точек.

**Request Body** — `PlanRequest` (см. выше).

**Response 200**
```json
{
  "stops": [
    {
      "name": "Ростовский краеведческий музей",
      "lat": 47.2174,
      "lon": 39.7071,
      "arrive": "2025-10-27T10:45:00",
      "leave": "2025-10-27T12:00:00",
      "tags": ["museum", "history"]
    },
    ...
  ],
  "total_time": "7ч 30мин",
  "total_minutes": 450,
  "ics": "BEGIN:VCALENDAR\nVERSION:2.0\n..."
}
```

Поле `ics` содержит календарь с блоком `VTIMEZONE` (Europe/Moscow), где каждое событие включает `DTSTART/DTEND` с указанием часового пояса и краткое описание остановки.

**Ошибки**
| Код | Причина |
|-----|---------|
| 400 | Некорректный JSON или отсутствует `date`. |
| 500 | Проблемы с 2ГИС (кроме 404), либо внутренние ошибки. Форс-мажор обрабатывается логами. |

Если 2ГИС не вернул данных, маршрут строится поверх сидов и может быть менее релевантным для указанной геопозиции.

### `POST /plan/ics`
Возвращает тот же маршрут, что и `/plan`, но сразу в виде файла `.ics`.

**Request** — структура `PlanRequest`.

**Response 200**
- `Content-Type: text/calendar`
- `Content-Disposition: attachment; filename="route_<date>.ics"`
- Тело содержит календарь с таймзоной Europe/Moscow и описанием остановок.

### `POST /llm/next`
Помогает построить диалог с пользователем (сбор предпочтений).

**Request**
```json
{"known_prefs": {"date": "2025-10-27", "tags": ["history"]}}
```

**Response**
- `mode="ask"` — вернёт следующий вопрос; содержит поля `question`, `field`, `input`, `options`.
- `mode="ready"` — prefs собраны, можно вызывать `/plan`.

В отсутствие LLM работает fallback-сценарий (дата → теги → бюджет → темп).

### `POST /llm/explain`
Генерирует текстовое объяснение маршрута.

**Request**
```json
{
  "prefs": {"date": "2025-10-27", "tags": ["history"], "budget": "medium"},
  "stops": [ { "name": "...", "arrive": "...", "leave": "...", "tags": ["history"] } ]
}
```

**Response**
```json
{"text": "Начинаем с музея, потом обед неподалёку и прогулка в парке."}
```

Без LLM возвращается простая заготовка.

## Поведение при ошибках 2ГИС

| Ситуация | Действие |
|----------|----------|
| 404 `itemNotFound` | Возвращает пустой список, что приводит к использованию сидов. |
| 429/5xx | Ретраи с экспоненциальным бэкофом (0.5s → 1s). Если после ретраев неудача — выбрасывается исключение, клиент получает 500. |
| Ошибка сети | Ретраи по аналогии. |

## Кэширование

- Ключ строится из запроса (`endpoint`, координаты, радиус, страница, текст запроса).
- Сначала проверяется память, затем диск (`CACHE_DIR`).
- Стабильные запросы (`/plan` с одинаковыми параметрами) экономят лимит 2ГИС.
- Для обновления данных очистите директорию кэша или уменьшите `CACHE_TTL_PLACES_SEC`.

## Расширение

- Можно добавить другие каталоги (например, заведения) — достаточно расширить `TAG_QUERY_MAP` и словарь тегов.
- Для мультидневных маршрутов нужно переписать `route_logic` (учёт времени, ночёвок).
- В production рассмотрите rate-limiting и авторизацию (например, JWT).
